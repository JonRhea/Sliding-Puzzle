#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <string.h>

int boardSize;
int *board;

int zeroTile;
int tileMove;

extern int clientToServer[2];
extern int serverToClient[2];

enum command {cmd_pnt, cmd_move, cmd_quit, cmd_new, cmd_save, cmd_load};

int gameInterface();
void firstSetUp();
int serverWait();
int isMoveValid(int tile);
int * createGame();
void randomizeBoard();
void swap(int *a, int *b);
void printBoard();
void moveTile(int tile);
int checkWon();
int saveGame(char * filename);
int * loadGame(char * filename);
void teardown();

/*
* Creates a 4x4 board and prints it on start up.
*/
void firstSetUp(){	
	boardSize = 4;
	
	board = createGame();
	
	//tell client game has been set up
	int setUpFinished = 0;
	write(serverToClient[1], &setUpFinished, sizeof(int));
	
	printBoard();
	serverWait();
}//end firstSetUp

/*
* Wait for input command from client, interpret it, adn executes corresponding functions
*/
int serverWait(){

	enum command clientCmd;
	int tileToMove;
	char filename[12];
	
	while(clientCmd != cmd_quit){
		
		//check to see if game is won
		if(checkWon() == 1){
			int returnValue = 1;
			write(serverToClient[1], &returnValue, sizeof(int)); 
			teardown();
			return 0;
		}//end if
		else{
			int returnValue = 0;
			write(serverToClient[1], &returnValue, sizeof(int)); 
		}//end else
			
		//read command from client
		read(clientToServer[0], &clientCmd, sizeof(clientCmd));
			
		if(clientCmd == cmd_pnt){
			printBoard();
		}//end if
		else if(clientCmd == cmd_move){
			read(clientToServer[0], &tileToMove, sizeof(int));
			if(isMoveValid(tileToMove) == 1){
				moveTile(tileToMove);
			}//end if 
		}//end if
		else if(clientCmd == cmd_quit){
			teardown();
			close(serverToClient[1]);
			close(clientToServer[0]);
		}//end if
		else if(clientCmd == cmd_new){
			read(clientToServer[0], &boardSize, sizeof(int));
			free(board);
			board = createGame();
			printBoard();
		}//end if
		else if(clientCmd == cmd_save){
			int returnValueSave;
			read(clientToServer[0], filename, 12);
			if(saveGame(filename) == 1){ //if save is successful
					returnValueSave = 5;
					write(serverToClient[1], &returnValueSave, sizeof(int));
				}//end if
				else{ //if save is not successful
					returnValueSave = 6;
					write(serverToClient[1], &returnValueSave, sizeof(int));
				}//end else
		}//end if
		else if(clientCmd == cmd_load){
			read(clientToServer[0], filename, 12);
			board = loadGame(filename);
		}//end if
		else{ //default case, although this should never be hit b/c client takes care of unknown command
			//do nothing, error handeled by client
		}//end else		
	}//end while
}//end serverWait

/*
* Creates the board and fills it with the tiles
* @return The board generated by this method
*/
int * createGame(){
	
	int numberCounter = (boardSize * boardSize) - 1;
	board = (int*)malloc((boardSize * boardSize) * sizeof(int));
	
	if(board == NULL){
		printf("Memeory not allocated. Exiting.\n");
		exit(0);
	}//end if
	
	for(int i = 0; i < (boardSize * boardSize); i++){
		board[i] = numberCounter;
		--numberCounter;
	}//end for
	
	randomizeBoard(board);

	return board;
}//end createGame

/*
* Randomly selects two places of the board to swap
*/
void randomizeBoard(){
	srand(time(NULL));
	int i;
	for(i = (boardSize * boardSize) - 1; i > 0; i--){
		int j = rand() % (i + 1);
		swap(&board[i], &board[j]);
	}//end for
}//end randomize

/*
* Swaps two pointers. This is used to swap two locations on the board,
* which is randomly decided in createGame.
* @param *a: The first element to be swapped
* @param *b: The second element to be swapped
*/
void swap(int *a, int *b){
	int temp = *a;
	*a = *b;
	*b = temp;
}//end swap

/*
* Sends the boardSize and board to client so the client can print the board.
* @param * board: The current board
*/
void printBoard(){
	int clientDone;
	//send boardSize to client
	write(serverToClient[1], &boardSize, sizeof(boardSize));
	read(clientToServer[0], &clientDone, sizeof(clientDone));
	
	//send board to client now that the client knows the size
	write(serverToClient[1], board, (boardSize * boardSize) * sizeof(int));
	read(clientToServer[0], &clientDone, sizeof(clientDone));
	
	//wait for client to finish printing the board
	read(clientToServer[0], &clientDone, sizeof(clientDone));

	int returnValue = 2;
	write(serverToClient[1], &returnValue, sizeof(int));
}//end printBoard

/*
* Checks whether a tile can be moved (if a zero is next to it)
* @param * board: The current board
* @param tile: Tile number to move
* @return 1 if tile is moveable, 0 if not
*/
int isMoveValid(int tile){
	int boardSizeB = boardSize * boardSize;
	
	//check if free tile was entered
	if(tile == 0){
		int returnValue = 3;
		write(serverToClient[1], &returnValue, sizeof(int));
		return 0;
	}//end if
	
	//check if a tile that does not exist was entered.
	if((tile < 0)){
		int returnValue = 3;
		write(serverToClient[1], &returnValue, sizeof(int));
		return 0;
	}//end if
	if(tile > boardSizeB - 1){
		int returnValue = 3;
		write(serverToClient[1], &returnValue, sizeof(int));
		return 0;
	}//end if
	
	//loop through the board to find tile
	for(int i = 0; i < boardSizeB; i++){
		if(board[i] == tile){
			tileMove = i;		
				
			//check to see if the above tile is the free tile
			//do not check if tile is in the top row
			zeroTile = i - boardSize;
			if((i - boardSize) >= 0){ 
				if(board[i - boardSize] == 0)
					return 1;
			}//end if
			
			//check to see if the right tile is the free tile
			//do not check if tile is in the right column
			zeroTile = i + 1;
			if(i % boardSize != boardSize - 1){ 
				if(board[i + 1] == 0)
					return 1;
			}//end if
				
			//check to see if the below tile is the free tile
			//do not check if tile is in the bottom row
			zeroTile = i + boardSize;
			if((i + boardSize) <= boardSizeB - 1){
				if(board[i + boardSize] == 0)
					return 1;
			}//end if
				
			//check to see if the left tile is the free tile
			//do not check if tile is in the left column
			zeroTile = i - 1;
			if(i % boardSize != 0){
				if(board[i - 1] == 0)
					return 1;
			}//end if
				
			//if all four checks fail, the tile is not moveable.
					
			int returnValue = 3;
			write(serverToClient[1], &returnValue, sizeof(int));
			return 0;
		}//end if		
	}//end for
}//end isMoveValid

/*
* Moves a tile to the free spot (aka 0)
* @param * board: The current board.
* @param tile: The tile to be moved
*/
void moveTile(int tile){
	
	//move tile to where the free tile is
	board[zeroTile] = tile;
	
	//move free tile to where the tile is
	board[tileMove] = 0;

	int returnValue = 4;
	write(serverToClient[1], &returnValue, sizeof(int));
	
}//end moveTile

/*
* Checks to see if the numbers are sorted from 1 to last tile (game has been won)
* NOTE: The placement of the free (0) tile does not matter
* @param * board: The current board.
* @return 1 if the board is saved successfully, 0 is unsuccessful
*/
int checkWon(){
	
	//tileChecker will check for the board order. ie; if tileChecker is 5, the tile to be checked should be 5
	int tileChecker = 1;
	int looper;
	for(looper = 0; looper < boardSize * boardSize; looper++){

		if(board[looper] == tileChecker){
				tileChecker++;
		}//end 
		else if(board[looper] == 0){
			//do nothing, skip free tile and increment looper
		}//end if
		else{ //a tile is not in the correct place
			return 0;
		}//end else
	}//end for
	return 1;
}//end if

/*
* Saves the board size and current board to a file.
* The first line of the file will be the board size, the rest are the contents of board
* @param * board: The current board
*/
int saveGame(char * filename){
	FILE *f;
	//the biggest board will be 10x10 (100) plus 1 for the size of the board (101);
	f = fopen(filename, "w");
	
	if(f == NULL){
		return 0;
	}//end if
	
	//write boardSize first
	fprintf(f, "%d\n", boardSize);
	
	//now write the board
	int i = 0;
	while(i < (boardSize * boardSize)){
		fprintf(f, "%d\n", board[i]);
		i++;
	}//end while
	
	fclose(f);
	return 1;
}//end saveGame

/*
* Loads a saved board from savefile.txt
* @param * board: The curremt board. Will be freed in this method.
* @return newBoard if the board is successfully loaded. If not, the current board
* will be returned so the user can continue with the game.
*/
int * loadGame(char * filename){
	int returnValue;
	FILE *f;
	int *newBoard;
	
	f = fopen(filename, "r");
	
	if(f == NULL){
		returnValue = 8;
		write(serverToClient[1], &returnValue, sizeof(int));
		return board;
	}//end if
	
	int i = 0;
	//get the size of the saved board (line 1 of savefile.txt)
	fscanf(f, "%d", &i);
	boardSize = i;
	
	//if something is wrong with the file, return board.
	//easy way to check is by looking at line 1 (size) and see if it's within the range
	if(boardSize < 2 || boardSize > 10){
		returnValue = 8;
		write(serverToClient[1], &returnValue, sizeof(int));
		return board;
	}//if 
	
	//free the current board and malloc the saved board
	free(board);
	board = (int*)malloc((boardSize * boardSize) * sizeof(int));
	
	if(newBoard == NULL){
		exit(0);
	}//end if
	
	//load in the tiles from saved board
	for(i = 0; i < (boardSize * boardSize) + 1; i++){
		//skip the first line of savefile.txt
		if(i != 0)
			fscanf(f, "%2d", &board[i - 1]);
	}//end for
	
	fclose(f);
	
	returnValue = 7;
	write(serverToClient[1], &returnValue, sizeof(int));
	read(clientToServer[0], &returnValue, sizeof(int));
	printBoard();
	return board;
}//end loadGame

/*
* Frees the board
* @param * board: The current board. Only here to be freed.
*/
void teardown(){
	free(board);
}//end endGame