#include "includes.h"
#include "prototypes.h"

int boardSize;
int *board;

int zeroTile;
int tileMove;

int clientID;

int tileToMove;
char filename[12];

//get client_socket to send info to client
extern int client_socket;

/**
* Set up the game for the first time.
* @param clientCount: Uses client count from server to set clientID
*/
void firstSetUp(int clientCount){	
	clientID = clientCount;
	boardSize = 4;
	
	board = createGame();
	
	//tell client game has been set up
	int setUpFinished = 0;
	send(client_socket, &setUpFinished, sizeof(int), 0);
	
	printBoard();
	serverWait(clientID);
}//end firstSetUp

//Helper functions are use for clairty and so that they can be in sp-game.c

/**
* Helper function for move command
*/
void doMove(){
	recv(client_socket, &tileToMove, sizeof(int), 0);
	if(isMoveValid(tileToMove) == 1){
		moveTile(tileToMove);
	}//end if 
}//end doMove

/**
* Helper function for quit command
*/
void doQuit(){
	teardown();
}//end doQuit

/**
* Helper function for new command
*/
void doNew(){
	recv(client_socket, &boardSize, sizeof(int), 0);
	free(board);
	board = createGame();
	printBoard();
}//end doNew

/**
* Helper function for save command
*/
void doSave(){
	int returnValueSave;
	recv(client_socket, filename, 12, 0);
	if(saveGame(filename) == 1){ //if save is successful
		returnValueSave = 5;					
		send(client_socket, &returnValueSave, sizeof(int), 0);
	}//end if
	else{ //if save is not successful
		returnValueSave = 6;
		send(client_socket, &returnValueSave, sizeof(int), 0);
	}//end else
}//end doSave

/**
* Helper function for load command
*/
void doLoad(){
	recv(client_socket, filename, 12, 0);
	board = loadGame(filename);
}//end doLoad

/*
* Creates the board and fills it with the tiles
* @return The board generated by this method
*/
int * createGame(){
	
	int numberCounter = (boardSize * boardSize) - 1;
	board = (int*)malloc((boardSize * boardSize) * sizeof(int));
	
	if(board == NULL){
		printf("Memeory not allocated. Exiting.\n");
		exit(0);
	}//end if
	
	for(int i = 0; i < (boardSize * boardSize); i++){
		board[i] = numberCounter;
		--numberCounter;
	}//end for
	
	randomizeBoard(board);

	return board;
}//end createGame

/**
* Randomly selects two places of the board to swap
*/
void randomizeBoard(){
	srand(time(NULL));
	int i;
	for(i = (boardSize * boardSize) - 1; i > 0; i--){
		int j = rand() % (i + 1);
		swap(&board[i], &board[j]);
	}//end for
}//end randomize

/**
* Swaps two pointers. This is used to swap two locations on the board,
* which is randomly decided in createGame.
* @param *a: The first element to be swapped
* @param *b: The second element to be swapped
*/
void swap(int *a, int *b){
	int temp = *a;
	*a = *b;
	*b = temp;
}//end swap

/**
* Sends the boardSize and board to client so the client can print the board.
* @param * board: The current board
*/
void printBoard(){
	int clientDone;
	//send boardSize to client
	send(client_socket, &boardSize, sizeof(boardSize), 0);
	recv(client_socket, &clientDone, sizeof(clientDone), 0);
	//printf("cliendDone %d\n", clientDone);
	
	//send board to client now that the client knows the size
	send(client_socket, board, (boardSize * boardSize) * sizeof(int), 0);
	recv(client_socket, &clientDone, sizeof(clientDone), 0);
	
	//printf("cliendDone board %d\n", clientDone);
	//wait for client to finish printing the board
	recv(client_socket, &clientDone, sizeof(clientDone), 0);

	//printf("cliendDone print  %d\n", clientDone);
	int returnValue = 2;
	send(client_socket, &returnValue, sizeof(int), 0);
}//end printBoard

/**
* Checks whether a tile can be moved (if a zero is next to it)
* @param * board: The current board
* @param tile: Tile number to move
* @return 1 if tile is moveable, 0 if not
*/
int isMoveValid(int tile){
	int boardSizeB = boardSize * boardSize;
	
	//check if free tile was entered
	if(tile == 0){
		int returnValue = 3;
		send(client_socket, &returnValue, sizeof(int), 0);
		return 0;
	}//end if
	
	//check if a tile that does not exist was entered.
	if((tile < 0)){
		int returnValue = 3;
		send(client_socket, &returnValue, sizeof(int), 0);
		return 0;
	}//end if
	if(tile > boardSizeB - 1){
		int returnValue = 3;
		send(client_socket, &returnValue, sizeof(int), 0);
		return 0;
	}//end if
	
	//loop through the board to find tile
	for(int i = 0; i < boardSizeB; i++){
		if(board[i] == tile){
			tileMove = i;		
				
			//check to see if the above tile is the free tile
			//do not check if tile is in the top row
			zeroTile = i - boardSize;
			if((i - boardSize) >= 0){ 
				if(board[i - boardSize] == 0)
					return 1;
			}//end if
			
			//check to see if the right tile is the free tile
			//do not check if tile is in the right column
			zeroTile = i + 1;
			if(i % boardSize != boardSize - 1){ 
				if(board[i + 1] == 0)
					return 1;
			}//end if
				
			//check to see if the below tile is the free tile
			//do not check if tile is in the bottom row
			zeroTile = i + boardSize;
			if((i + boardSize) <= boardSizeB - 1){
				if(board[i + boardSize] == 0)
					return 1;
			}//end if
				
			//check to see if the left tile is the free tile
			//do not check if tile is in the left column
			zeroTile = i - 1;
			if(i % boardSize != 0){
				if(board[i - 1] == 0)
					return 1;
			}//end if
				
			//if all four checks fail, the tile is not moveable.
					
			int returnValue = 3;
			send(client_socket, &returnValue, sizeof(int), 0);
			return 0;
		}//end if		
	}//end for
}//end isMoveValid

/**
* Moves a tile to the free spot (aka 0)
* @param * board: The current board.
* @param tile: The tile to be moved
*/
void moveTile(int tile){
	
	//move tile to where the free tile is
	board[zeroTile] = tile;
	
	//move free tile to where the tile is
	board[tileMove] = 0;

	int returnValue = 4;
	send(client_socket, &returnValue, sizeof(int), 0);
	
}//end moveTile

/**
* Checks to see if the numbers are sorted from 1 to last tile (game has been won)
* NOTE: The placement of the free (0) tile does not matter
* @param * board: The current board.
* @return 1 if the board is saved successfully, 0 is unsuccessful
*/
int checkWon(){
	
	//tileChecker will check for the board order. ie; if tileChecker is 5, the tile to be checked should be 5
	int tileChecker = 1;
	int looper;
	for(looper = 0; looper < boardSize * boardSize; looper++){

		if(board[looper] == tileChecker){
				tileChecker++;
		}//end 
		else if(board[looper] == 0){
			//do nothing, skip free tile and increment looper
		}//end if
		else{ //a tile is not in the correct place
			return 0;
		}//end else
	}//end for
	return 1;
}//end if

/**
* Saves the board size and current board to a file.
* The first line of the file will be the board size, the rest are the contents of board
* @param * board: The current board
*/
int saveGame(char * filename){
	FILE *f;
	//the biggest board will be 10x10 (100) plus 1 for the size of the board (101);
	f = fopen(filename, "w");
	
	if(f == NULL){
		return 0;
	}//end if
	
	//write boardSize first
	fprintf(f, "%d\n", boardSize);
	
	//now write the board
	int i = 0;
	while(i < (boardSize * boardSize)){
		fprintf(f, "%d\n", board[i]);
		i++;
	}//end while
	
	fclose(f);
	return 1;
}//end saveGame

/**
* Loads a saved board from savefile.txt
* @param * board: The curremt board. Will be freed in this method.
* @return newBoard if the board is successfully loaded. If not, the current board
* will be returned so the user can continue with the game.
*/
int * loadGame(char * filename){
	int returnValue;
	FILE *f;
	int *newBoard;
	
	f = fopen(filename, "r");
	
	if(f == NULL){
		returnValue = 8;
		send(client_socket, &returnValue, sizeof(int), 0);
		return board;
	}//end if
	
	int i = 0;
	//get the size of the saved board (line 1 of savefile.txt)
	fscanf(f, "%d", &i);
	boardSize = i;
	
	//if something is wrong with the file, return board.
	//easy way to check is by looking at line 1 (size) and see if it's within the range
	if(boardSize < 2 || boardSize > 10){
		returnValue = 8;
		send(client_socket, &returnValue, sizeof(int), 0);
		return board;
	}//if 
	
	//free the current board and malloc the saved board
	free(board);
	board = (int*)malloc((boardSize * boardSize) * sizeof(int));
	
	if(newBoard == NULL){
		exit(0);
	}//end if
	
	//load in the tiles from saved board
	for(i = 0; i < (boardSize * boardSize) + 1; i++){
		//skip the first line of savefile.txt
		if(i != 0)
			fscanf(f, "%2d", &board[i - 1]);
	}//end for
	
	fclose(f);
	
	returnValue = 7;
	send(client_socket, &returnValue, sizeof(int), 0);
	recv(client_socket, &returnValue, sizeof(int), 0);
	printBoard();
	return board;
}//end loadGame

/*
* Frees the board and closes the client socket
* @param * board: The current board. Only here to be freed.
*/
void teardown(){
	free(board);
	close(client_socket);
	printf("Client closed\n");
}//end endGame