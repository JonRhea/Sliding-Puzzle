#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int isMoveValid(int * board, int tile);
int * createGame();
void swap(int *a, int *b);
void printBoard(int * board);
void moveTile(int * board, int tile);
int checkWon(int * board);
int saveGame(int * board);
int * loadGame(int * board);
void teardown(int * board);

int boardSize;
int zeroTile;
int tileMove;

/*
* Starts the program, containts the loop, and terminates the program
* @return 0 The program has ended.
*/
int main(){
	
	printf("Setting up the game.\n");
	
	boardSize = 4;
	int *boardPointer;
	
	boardPointer = createGame();
	
	
	printBoard(boardPointer);
	//where the user's input will be stored
	char choice;
	
	//this is used to check if the board size is between 2 and 10 for option 'n'
	int okaySize;
	
	/*Six optipons for input:
	* 'p' - Prints the current board
	* 'm' - User is prompted to enter a tile to move, then moves that tile
	* 'q' - Quits the game (terminates the program)
	* 'n' - Prompts the user for a new board size, then creates a new board
	* 's' - Saves the current board to savefile.txt
	* 'l' - Loads a board from savefile.txt
	* Any other option resutls in an error message and an option to try again.*/
	while(choice != 'q'){

		printf("\nSelect and option:\np - Print the game state\nm - Move a tile\nq - Quit the game\nn - Create a new board\ns - Save the board\nl - Load a game from savefile\n>");
		scanf("%s" , &choice);//get input from the user
		
		switch(choice){
			case 'p':
				printBoard(boardPointer);
			break;
			case 'm':
				printf("Enter a tile to move.\n>");
				int tile;
				scanf("%d", &tile);
				if(isMoveValid(boardPointer, tile) == 1){
					moveTile(boardPointer, tile);
				}//end if 
			break;
			case 'q':
				printf("Ending the game.\n");
				teardown(boardPointer);
			break;
			case 'n':
				okaySize = 0;
				while(okaySize == 0){
					printf("Enter the size of the board (between 2 and 10).\n>");
					scanf("%d", &boardSize);
					
					if(boardSize < 2 || boardSize > 10){
						printf("Board size must be between 2 and 10. Please try again.\n\n");
					}//end if
					else{
						okaySize = 1;
					}//end else
				}//end while
				//free current board and create a new board
				free(boardPointer);
				boardPointer = createGame();
				printf("A new board has been created.\n");
				printBoard(boardPointer);
			break;
			case 's':
				if(saveGame(boardPointer) == 1){
					printf("The board was saved successfully.\n");
				}//end if
				else{
					printf("The board could not be saved.\n");
				}//end else
			break;
			case 'l':
				boardPointer = loadGame(boardPointer);
			break;
			default:
				printf("Unknown command. Please try again.\n");
			
		}//end switch
		
		//check after each action is the board has been solved
		if(checkWon(boardPointer) == 1){
			printf("You won the game!\n");
			teardown(boardPointer);
			return 0;
		}//end if
	}//end while
		
	return 0;
}//end main

/*
* Creates the board and fills it with the tiles
* @return The board generated by this method
*/
int * createGame(){
	
	int numberCounter = (boardSize * boardSize) - 1;
	int *boardPointer;
	boardPointer = (int*)malloc((boardSize * boardSize) * sizeof(int));
	
	if(boardPointer == NULL){
		printf("Memeory not allocated. Exiting.\n");
		exit(0);
	}//end if
	
	for(int i = 0; i < (boardSize * boardSize); i++){
		boardPointer[i] = numberCounter;
		//printf(" %d\n", boardPointer[i]);
		--numberCounter;
	}//end for
	
	//randomly swap two places in the board
	srand(time(NULL));
	int i;
	for(i = (boardSize * boardSize) - 1; i > 0; i--){
		int j = rand() % (i + 1);
		swap(&boardPointer[i], &boardPointer[j]);
	}//end for

	return boardPointer;
}//end createGame

/*
* Swaps two pointers. This is used to swap two locations on the board,
* which is randomly decided in createGame.
* @param *a: The first element to be swapped
* @param *b: The second element to be swapped
*/
void swap(int *a, int *b){
	int temp = *a;
	*a = *b;
	*b = temp;
}//end swap

/*
* Prints the current state of the board
* @param * board: The current board
*/
void printBoard(int * board){
	for(int i = 0; i < boardSize * boardSize; i++){
		if(board[i]!= 0){
			//printf("Printing contents\n");
			printf("%3d ", board[i]);
		}
		else
			//this 3 space print will create the free space in the printed board
			printf("    ");

		//print a new line whenever a row is finished printing
		//skip for i = 0 because program will crash if 0 % x is trying to be calculated
		if(i != 0){
			if(i % boardSize == boardSize - 1){
				printf("\n");
			}//end if
		}//end if
	}//end for
	
}//end printBoard

/*
* Checks whether a tile can be moved (if a zero is next to it)
* @param * board: The current board
* @param tile: Tile number to move
* @return 1 if tile is moveable, 0 if not
*/
int isMoveValid(int * board, int tile){
	int boardSizeB = boardSize * boardSize;
	
	//check if free tile was entered
	if(tile == 0){
		printf("The free tile cannot be moved!\n");
		return 0;
	}//end if
	
	//check if a tile that does not exist was entered.
	if((tile < 0)){
		printf("Negative numbers cannot be used in this game.\n");
		return 0;
	}//end if
	if(tile > boardSizeB - 1){
		printf("Tile does not exist.\n");
		return 0;
	}//end if
	
	//loop through the board to find tile
	for(int i = 0; i < boardSizeB; i++){
		if(board[i] == tile){
			tileMove = i;		
				
			//check to see if the above tile is the free tile
			//do not check if tile is in the top row
			zeroTile = i - boardSize;
			if((i - boardSize) >= 0){ 
				if(board[i - boardSize] == 0)
					//zeroTileMove = i - boardSize;
					return 1;
			}//end if
			
			//check to see if the right tile is the free tile
			//do not check if tile is in the right column
			zeroTile = i + 1;
			if(i % boardSize != boardSize - 1){ 
				if(board[i + 1] == 0)
					//zeroTileMove = i + 1;
					return 1;
			}//end if
				
			//check to see if the below tile is the free tile
			//do not check if tile is in the bottom row
			zeroTile = i + boardSize;
			if((i + boardSize) <= boardSizeB - 1){
				if(board[i + boardSize] == 0)
					//zeroTileMove = i + boardSize;
					return 1;
			}//end if
				
			//check to see if the left tile is the free tile
			//do not check if tile is in the left column
			zeroTile = i - 1;
			if(i % boardSize != 0){
				if(board[i - 1] == 0)
					//zeroTileMove = i - 1;
					return 1;
			}//end if
				
			//if all four checks fail, the tile is not moveable.
			printf("The tile cannot be moved.\n");
			return 0;
		}//end if		
	}//end for
}//end isMoveValid

/*
* Moves a tile to the free spot (aka 0)
* @param * board: The current board.
* @param tile: The tile to be moved
*/
void moveTile(int * board, int tile){
	
	//move tile to where the free tile is
	board[zeroTile] = tile;
	
	//move free tile to where the tile is
	board[tileMove] = 0;
	
	printf("The tile has been moved successfully.\n");
	
}//end moveTile

/*
* Checks to see if the numbers are sorted from 1 to last tile (game has been won)
* NOTE: The placement of the free (0) tile does not matter
* @param * board: The current board.
* @return 1 if the board is saved successfully, 0 is unsuccessful
*/
int checkWon(int * board){
	
	//tileChecker will check for the board order. ie; if tileChecker is 5, the tile to be checked should be 5
	int tileChecker = 1;
	int looper;
	for(looper = 0; looper < boardSize * boardSize; looper++){

		if(board[looper] == tileChecker){
				tileChecker++;
		}//end 
		else if(board[looper] == 0){
			//do nothing, skip free tile and increment looper
		}//end if
		else{ //a tile is not in the correct place
			return 0;
		}//end else
	}//end for
	return 1;
}//end if

/*
* Saves the board size and current board to a file.
* The first line of the file will be the board size, the rest are the contents of board
* @param * board: The current board
*/
int saveGame(int * board){
	FILE *f;
	//the biggest board will be 10x10 (100) plus 1 for the size of the board (101)
	char buffer[101];
	f = fopen("savefile.txt", "w");
	
	if(f == NULL){
		printf("Error opening savefile.\n");
		return 0;
	}//end if
	
	//write boardSize first
	fprintf(f, "%d\n", boardSize);
	
	//now write the board
	int i = 0;
	while(i < (boardSize * boardSize)){
		fprintf(f, "%d\n", board[i]);
		i++;
	}//end while
	
	fclose(f);
	return 1;
}//end saveGame

/*
* Loads a saved board from savefile.txt
* @param * board: The curremt board. Will be freed in this method.
* @return newBoard if the board is successfully loaded. If not, the current board
* will be returned so the user can continue with the game.
*/
int * loadGame(int * board){
	FILE *f;
	int *newBoard;
	
	f = fopen("savefile.txt", "r");
	
	if(f == NULL){
		printf("Error saving game to savefile.\n");
		return board;
	}//end if
	
	int i = 0;
	//get the size of the saved board (line 1 of savefile.txt)
	fscanf(f, "%d", &i);
	boardSize = i;
	
	//if something is wrong with the file, return board.
	//easy way to check is by looking at line 1 (size) and see if it's within the range
	if(boardSize < 2 || boardSize > 10){
		printf("Error loading save data.\n");
		return board;
	}//if 
	
	//teardown the current board and malloc the saved board
	teardown(board);
	newBoard = (int*)malloc((boardSize * boardSize) * sizeof(int));
	
	if(newBoard == NULL){
		printf("Memeory not allocated. Exiting.\n");
		exit(0);
	}//end if
	
	//load in the tiles from saved board
	for(i = 0; i < (boardSize * boardSize) + 1; i++){
		//skip the first line of savefile.txt
		if(i != 0)
			fscanf(f, "%2d", &newBoard[i - 1]);
	}//end for
	
	fclose(f);
	
	printf("Game loaded successfully.\n");
	printBoard(newBoard);
	return newBoard;
}//end loadGame

/*
* Frees the board
* @param * board: The current board. Only here to be freed.
*/
void teardown(int * board){
	free(board);
}//end endGame